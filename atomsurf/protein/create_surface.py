import os
import sys

import numpy as np
import open3d as o3d
import pandas as pd
from pathlib import Path
import subprocess
import trimesh

if __name__ == '__main__':
    script_dir = os.path.dirname(os.path.realpath(__file__))
    sys.path.append(os.path.join(script_dir, '..', '..'))

from atomsurf.utils.python_utils import silentremove

"""
In this file, we define functions to make the following transformations :
PDB -> MSMS surfaces as vert and faces 
MSMS surface -> refined one, saved as .ply
"""


def parse_verts(vert_file, face_file, keep_normals=False):
    """
    Generate the vertices and faces (and optionally the normals) from .vert and .face files generated by MSMS
    :param vert_file:
    :param face_file:
    :param keep_normals:
    :return:
    """
    with open(vert_file, 'r', errors='ignore') as f:
        # Parse the file and ensure it looks sound
        lines = f.readlines()
        n_vert = int(lines[2].split()[0])
        no_header = lines[3:]
        assert len(no_header) == n_vert

        # Parse the info to retrieve vertices and normals
        lines = [line.split()[:6] for line in no_header]
        lines = np.array(lines).astype(np.float32)
        verts = lines[:, :3]
        if keep_normals:
            normals = lines[:, 3:6]

    with open(face_file, 'r', errors='ignore') as f:
        # Parse the file and ensure it looks sound
        lines = f.readlines()
        n_faces = int(lines[2].split()[0])
        no_header = lines[3:]
        assert len(no_header) == n_faces

        # Parse the lines and remove 1 to get zero based indexing
        lines = [line.split() for line in no_header]
        lines = np.array(lines).astype(np.int32)
        faces = lines[:, :3]
        faces -= 1

    if keep_normals:
        return verts, faces, normals
    else:
        return verts, faces


def pdb_to_surf(pdb_path, out_name=None, density=1., remove_files=True):
    """
    Runs msms on the input PDB file and dumps the output in out_name
    :param pdb_path:
    :param out_name:
    :return:
    """
    if out_name is None:
        out_name = pdb_path
    out_name = str(Path(out_name).with_suffix(''))
    vert_file = out_name + '.vert'
    face_file = out_name + '.face'
    xyzr_name = f"{out_name}_temp.xyzr"
    log_name = f"{out_name}_msms.log"

    script_dir = os.path.dirname(os.path.realpath(__file__))
    binary_path = os.path.join(script_dir, "..", "..", "bin")
    msms_path = os.path.join(binary_path, "msms")
    pdb2xyzr_path = os.path.join(binary_path, "pdb_to_xyzr")
    try:
        # First get the xyzr file
        with open(xyzr_name, "w") as f:
            subprocess.run([pdb2xyzr_path, pdb_path], stdout=f)

        # Then run msms on this file
        cline = f"{msms_path} -if {xyzr_name} -of {out_name} -density {density}"
        with open(log_name, "w") as f:
            result = subprocess.run(cline.split(), stdout=f, stderr=f, timeout=30)
        if result.returncode != 0:
            print(f"*** An error occurred while executing the command: {cline}, see log file for details. *** ")
            raise RuntimeError(f"MSMS failed with return code {result.returncode}")
        verts, faces = parse_verts(vert_file=vert_file, face_file=face_file)
    except Exception as e:
        raise e
    finally:
        if remove_files:
            silentremove(xyzr_name)
            silentremove(log_name)
            silentremove(vert_file)
            silentremove(face_file)
    return verts, faces


def pdb_to_surf_with_min(pdb_path, out_name=None, min_number=256, remove_files=True):
    """
    This function is useful to retrieve at least min_number vertices, which is useful for later use in DiffNets
    :param pdb_path:
    :param out_name:
    :param min_number:
    :return:
    """

    number_of_vertices = 0
    density = 1.
    verts, faces = None, None
    while number_of_vertices < min_number:
        verts, faces = pdb_to_surf(pdb_path=pdb_path, out_name=out_name, density=density, remove_files=remove_files)
        number_of_vertices = len(verts)
        density += 1
    return verts, faces


"""
Clean the MSMS surfae
"""


def remove_abnormal_triangles(verts, faces):
    """Remove abnormal triangles (angles ~180 or ~0) in the mesh

    Returns:
        pymesh.Mesh, a new mesh with abnormal faces removed
    """
    v1 = verts[faces[:, 0]]
    v2 = verts[faces[:, 1]]
    v3 = verts[faces[:, 2]]
    e1 = v3 - v2
    e2 = v1 - v3
    e3 = v2 - v1
    L1 = np.linalg.norm(e1, axis=1)
    L2 = np.linalg.norm(e2, axis=1)
    L3 = np.linalg.norm(e3, axis=1)
    cos1 = np.einsum('ij,ij->i', -e2, e3) / (L2 * L3)
    cos2 = np.einsum('ij,ij->i', e1, -e3) / (L1 * L3)
    cos3 = np.einsum('ij,ij->i', -e1, e2) / (L1 * L2)
    cos123 = np.concatenate((cos1.reshape(-1, 1),
                             cos2.reshape(-1, 1),
                             cos3.reshape(-1, 1)), axis=-1)
    valid_faces = np.where(np.all(1 - cos123 ** 2 > 1E-5, axis=-1))[0]
    faces_new = faces[valid_faces]
    return verts, faces_new


def check_mesh_validity(mesh, check_triangles=False):
    """Check if a mesh is valid by following criteria

    1) disconnected
    2) has isolated vertex
    3) face has duplicated vertices (same vertex on a face)
    4) has triangles with angle ~0 or ~180

    Returns
        four-tuple of bool: above criteria

    """
    mesh.enable_connectivity()
    verts, faces = mesh.vertices, mesh.faces

    # check if a manifold is all-connected using BFS
    visited = np.zeros(len(verts)).astype(bool)
    groups = []
    for ivert in range(len(verts)):
        if visited[ivert]:
            continue
        old_visited = visited.copy()
        queue = [ivert]
        visited[ivert] = True
        while queue:
            curr = queue.pop(0)
            for nbr in mesh.get_vertex_adjacent_vertices(curr):
                if not visited[nbr]:
                    queue.append(nbr)
                    visited[nbr] = True
        groups.append(np.where(np.logical_xor(old_visited, visited))[0])
    groups = sorted(groups, key=lambda x: len(x), reverse=True)
    assert sum(len(ig) for ig in groups) == sum(visited) == len(verts)
    disconnected = len(groups) > 1

    # check for isolated vertices
    valid_verts = np.unique(faces)
    has_isolated_verts = verts.shape[0] != len(valid_verts)

    # check for faces with duplicate vertices
    df = pd.DataFrame(faces)
    df = df[df.nunique(axis=1) == 3]
    has_duplicate_verts = df.shape[0] != mesh.num_faces

    # check for abnormal triangles
    if check_triangles:
        v1 = verts[faces[:, 0]]
        v2 = verts[faces[:, 1]]
        v3 = verts[faces[:, 2]]
        e1 = v3 - v2
        e2 = v1 - v3
        e3 = v2 - v1
        L1 = np.linalg.norm(e1, axis=1)
        L2 = np.linalg.norm(e2, axis=1)
        L3 = np.linalg.norm(e3, axis=1)
        cos1 = np.einsum('ij,ij->i', -e2, e3) / (L2 * L3)
        cos2 = np.einsum('ij,ij->i', e1, -e3) / (L1 * L3)
        cos3 = np.einsum('ij,ij->i', -e1, e2) / (L1 * L2)
        cos123 = np.concatenate((cos1.reshape(-1, 1),
                                 cos2.reshape(-1, 1),
                                 cos3.reshape(-1, 1)), axis=-1)
        valid_faces = np.where(np.all(1 - cos123 ** 2 >= 1E-5, axis=-1))[0]
        has_abnormal_triangles = faces.shape[0] != len(valid_faces)
    else:
        has_abnormal_triangles = False

    return disconnected, has_isolated_verts, has_duplicate_verts, has_abnormal_triangles


def mesh_simplification(verts, faces, out_ply,
                        face_reduction_rate=1.,
                        min_vert_number=140,
                        max_vert_number=50000,
                        use_pymesh=True):
    """
    Simplify and clean a mesh.
    Simplification is based on coarsening with iterative quadratic decimation
    Cleaning involves discarding small disconnected components, unreferenced faces and vertices...

    Most of the computation time resides in the coarsening.
    """

    # remeshing to have a target number of vertices
    faces_num = max(min_vert_number * 2 + 1, int(face_reduction_rate * len(faces)))
    mesh = o3d.geometry.TriangleMesh(o3d.utility.Vector3dVector(verts), o3d.utility.Vector3iVector(faces))
    # big_name = out_ply.replace('.ply', '_big.ply')
    # print('saving', big_name)
    # o3d.io.write_triangle_mesh(big_name, mesh)

    # Clean with open3d
    mesh.remove_non_manifold_edges()
    mesh.remove_duplicated_vertices()
    mesh.remove_degenerate_triangles()
    mesh.remove_duplicated_triangles()
    mesh.remove_unreferenced_vertices()

    mesh = mesh.simplify_quadric_decimation(target_number_of_triangles=faces_num)

    verts_out = np.asarray(mesh.vertices)
    faces_out = np.asarray(mesh.triangles)

    if not use_pymesh:
        # TODO time
        triangle_clusters, cluster_n_triangles, _ = mesh.cluster_connected_triangles()
        triangle_clusters = np.asarray(triangle_clusters)
        cluster_n_triangles = np.asarray(cluster_n_triangles)

        # Some tiny clusters might exist, we want to remove those
        cutoff = int(0.01 * cluster_n_triangles[0])
        assert (cluster_n_triangles >= cutoff).sum() == 1
        triangles_to_remove = cluster_n_triangles[triangle_clusters] < cutoff
        mesh.remove_triangles_by_mask(triangles_to_remove)
        mesh.remove_unreferenced_vertices()
        mesh.remove_degenerate_triangles()

    if use_pymesh:
        import pymesh
        # cleaning the mesh with Pymesh
        mesh_py = pymesh.form_mesh(verts_out, faces_out)
        disconnected, isolated_verts, duplicate_verts, abnormal_triangles = check_mesh_validity(mesh_py,
                                                                                                check_triangles=True)
        _ = not (disconnected or isolated_verts or duplicate_verts or abnormal_triangles)

        # mesh_py = pymesh.form_mesh_py(verts, faces)
        mesh_py, _ = pymesh.remove_duplicated_vertices(mesh_py, 1E-6)  # duplicate
        mesh_py, _ = pymesh.remove_degenerated_triangles(mesh_py, 100)  # colinear vertices

        num_verts = mesh_py.num_vertices
        iteration = 0
        while iteration < 10:
            mesh_py, _ = pymesh.collapse_short_edges(mesh_py, rel_threshold=0.1)
            mesh_py, _ = pymesh.remove_obtuse_triangles(mesh_py, 170.0, 100)
            if abs(mesh_py.num_vertices - num_verts) < 20:
                break
            num_verts = mesh_py.num_vertices
            iteration += 1

        mesh_py = pymesh.resolve_self_intersection(mesh_py)
        mesh_py, _ = pymesh.remove_duplicated_faces(mesh_py)  # easy
        mesh_py, _ = pymesh.remove_obtuse_triangles(mesh_py, 179.0, 100)
        mesh_py = pymesh.form_mesh(*remove_abnormal_triangles(mesh_py.vertices, mesh_py.faces))
        mesh_py, _ = pymesh.remove_isolated_vertices(mesh_py)  # vertices not in faces, easy with index
        verts_py, faces_py = np.array(mesh_py.vertices, dtype=np.float32), np.array(mesh_py.faces, dtype=np.int32)

        disconnected, isolated_verts, duplicate_verts, abnormal_triangles = check_mesh_validity(mesh_py,
                                                                                                check_triangles=True)
        is_valid_mesh = not (disconnected or isolated_verts or duplicate_verts or abnormal_triangles)

        # Just a few assessments of the usefullness of PyMesh
        # size_diff = len(verts) - len(faces_py)
        # print('original', len(verts), 'coarsened', len(verts_out), 'corrected', len(verts_py), 'size_diff', size_diff,
        #       'valid_first', is_valid_mesh_first, 'valid', is_valid_mesh)
        # a = faces_py - faces_out
        # a = faces_py - faces
        # b = verts_py - verts
        # print(np.max(np.abs(a)), np.max(np.abs(b)))
        # if not is_valid_mesh_first:
        #     print(is_valid_mesh_first, is_valid_mesh)
        if not is_valid_mesh:
            raise ValueError('Mesh is not valid')
        verts_out = verts_py
        faces_out = faces_py

    if verts_out.shape[0] > max_vert_number:
        raise ValueError(f'Too many vertices in the mesh: {verts_out.shape[0]}')

    if verts_out.shape[0] < min_vert_number:
        raise ValueError(f'Not enough vertices in the mesh: {verts_out.shape[0]}')

    # save to ply
    if out_ply is not None:
        mesh = o3d.geometry.TriangleMesh(o3d.utility.Vector3dVector(verts_out), o3d.utility.Vector3iVector(faces_out))
        o3d.io.write_triangle_mesh(out_ply, mesh, write_vertex_normals=True)

    verts_out = verts_out.astype(np.float32)
    faces_out = faces_out.astype(np.int32)

    # remove duplicate
    mesh = trimesh.Trimesh(vertices=verts_out, faces=faces_out, preprocess=True)
    verts_out = np.array(mesh.vertices).astype(np.float32)
    faces_out = np.array(mesh.faces).astype(np.int32)

    return verts_out, faces_out


def get_surface(pdb_path="../../data/example_files/4kt3.pdb",
                out_ply_path=None,
                face_reduction_rate=1.,
                min_vert_number=140,
                max_vert_number=50000,
                use_pymesh=True):
    # # Check that msms and with_min gives the right output
    verts, faces = pdb_to_surf_with_min(pdb_path, min_number=min_vert_number)
    verts, faces = mesh_simplification(verts=verts,
                                       faces=faces,
                                       out_ply=out_ply_path,
                                       face_reduction_rate=face_reduction_rate,
                                       min_vert_number=min_vert_number,
                                       max_vert_number=max_vert_number,
                                       use_pymesh=use_pymesh)
    return verts, faces


def read_vertices_and_triangles(ply_file):
    """
    Just a small wrapper to retrieve directly the vertices and faces as np arrays with the right dtypes
    :param ply_file:
    :return:
    """
    mesh = o3d.io.read_triangle_mesh(filename=ply_file)
    vertices = np.asarray(mesh.vertices, dtype=np.float32)
    faces = np.asarray(mesh.triangles, dtype=np.int32)
    return vertices, faces


if __name__ == "__main__":
    pdb = "../../data/example_files/4kt3.pdb"
    outname = "../../data/example_files/test"
    vert_file = outname + '.vert'
    face_file = outname + '.face'

    # # Check that msms and with_min gives the right output
    # verts, faces = pdb_to_surf(pdb, out_name=outname, density=1., remove_files=False)
    # verts, faces = pdb_to_surf_with_min(pdb, out_name=outname, min_number=256, remove_files=False)
    # mesh = o3d.geometry.TriangleMesh(o3d.utility.Vector3dVector(verts), o3d.utility.Vector3iVector(faces))
    # # compute normal for rendering
    # mesh.compute_triangle_normals()
    # mesh.compute_vertex_normals()
    # o3d.visualization.draw_geometries([mesh])

    # Now simplify this into a coarser mesh (upper bound), and turn it into a corrected ply file
    # ply_file = "../../data/example_files/example_mesh.ply"
    # verts, faces = parse_verts(vert_file, face_file)
    # mesh_simplification(verts=verts,
    #                     faces=faces,
    #                     out_ply=ply_file,
    #                     use_pymesh=False,
    #                     face_reduction_rate=0.2)
    # mesh_reduced = o3d.io.read_triangle_mesh(ply_file)
    # mesh_reduced.compute_triangle_normals()
    # o3d.visualization.draw_geometries([mesh_reduced])

    verts, faces = get_surface(pdb_path="../../data/example_files/4kt3.pdb",
                               out_ply_path="../../data/example_files/example_mesh.ply",
                               min_vert_number=140,
                               use_pymesh=False,
                               face_reduction_rate=0.1)
