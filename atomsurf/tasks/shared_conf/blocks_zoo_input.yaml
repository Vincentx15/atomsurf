# HMR like encoder : angles to normals are computed and 16 nearest are sent to vertices
hmr_input_encoder_noneigh:
  name: HMRInputEncoder
  instanciate:
    _target_: atomsurf.networks.HMRInputEncoder
  kwargs:
    h_dim: ${model_hdim}
    use_neigh: False
    dropout: ${model_dropout}
    num_gdf: 16
    num_signatures: 16

hmr_input_encoder_neigh:
  name: HMRInputEncoder
  instanciate:
    _target_: atomsurf.networks.HMRInputEncoder
  kwargs:
    h_dim: ${model_hdim}
    use_neigh: True
    dropout: ${model_dropout}
    num_gdf: 16
    num_signatures: 16


# Message passing based encoder, messages goes both ways

input_encoder:
  name: InputEncoder
  instanciate:
    _target_: atomsurf.networks.InputEncoder
  kwargs:
    h_dim: ${model_hdim}
    dropout: ${model_dropout}
    num_gdf: 16
    num_signatures: 16
    use_bp: true
    use_gvp: true
    use_knn: false
    neigh_thresh: 8
    sigma: 2.5

input_encoder_normals:
  name: InputEncoder
  instanciate:
    _target_: atomsurf.networks.InputEncoder
  kwargs:
    h_dim: ${model_hdim}
    dropout: ${model_dropout}
    num_gdf: 16
    num_signatures: 16
    use_bp: true
    use_gvp: true
    use_knn: false
    use_normals: true
    neigh_thresh: 8
    sigma: 2.5

input_encoder_knn:
  name: InputEncoder
  instanciate:
    _target_: atomsurf.networks.InputEncoder
  kwargs:
    h_dim: ${model_hdim}
    dropout: ${model_dropout}
    num_gdf: 16
    num_signatures: 16
    use_bp: true
    use_gvp: true
    use_knn: true
    use_normals: true
    neigh_thresh: 8
    sigma: 2.5